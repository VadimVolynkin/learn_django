# https://djbook.ru/rel3.0/topics/db/models.html#overriding-model-methods

# ============================================================================
# НАСЛЕДОВАНИЕ В МОДЕЛЯХ ДЖАНГО
# ============================================================================
Базовый класс должен наследоваться от django.db.models.Model.
Есть 3 вида наследования моделей в Django:
- абстрактная модель
- multi-table наследование
- proxy-model



# ============================================================================
# АБСТРАКТНАЯ МОДЕЛЬ
# ============================================================================
Родительская модель для хранения общих полей дочерних моделей.
Определяет в метаклассе через abstract = True.
Не создает свои экземпляры, таблицу в БД, нет менеджера.
Поля абстрактной модели могут быть переопределены в дочерней или удалены с помощью None.
Если дочерний класс не определяет свой класс Meta, он унаследует родительский класс Meta. 
Если дочерняя модель хочет расширить родительский Meta класс, она может унаследовать его с атрибутом abstract=False. Так дочерняя модель, наследуя Meta, не становится сама абстрактной моделью.

class CommonInfo(models.Model):
    # ...
    class Meta:
        abstract = True
        ordering = ['name']

class Student(CommonInfo):
    # ...
    class Meta(CommonInfo.Meta):
        db_table = 'student_info'

В абстрактной модели поля отношений могут включать параметр related_name="%(app_label)s_%(class)s_related" - чтобы избежать дублирования уникальных имен. 
В абстрактной модели без указания related_name будет использовано название 'childmodel_set'.



# ============================================================================
# MULTI-TABLE НАСЛЕДОВАНИЕ
# ============================================================================
Родительская не абстрактная модель имеет собственную таблицу в БД и может быть использована независимо.
Такая родительская модель может быть взята например из другого приложения.

Связь между родительской и дочерней моделью происходит через автоматически созданное поле OneToOneField.
Используется название по умолчанию для атрибута related_name в ForeignKey и ManyToManyField.
Переопределить related_name можно создав собственное поле OneToOneField с parent_link=True чтобы указать, что это поле является связью с родительской моделью.

Если вы используете такие связи на дочернюю модель с аналогичным предком, вы должны определить related_name для каждого такого поля. Иначе Django вызовет исключение.

Дочерняя модель не имеет доступа к родительскому классу Meta, кроме случаев, когда дочерняя модель не определяет атрибут ordering или get_latest_by, они будут унаследованы.


# ============================================================================
# PROXY-MODEL НАСЛЕДОВАНИЕ
# ============================================================================
Переопределяет поведение модели на уровне Python, не меняя структуры БД.
Объекты proxy модели можно создать, изменять и все изменения будут сохранены так же, как и при изменении оригинальной(non-proxied) модели. 
Дочерние модели всегда синхронизированы с родительской моделью, они напрямую наследуют ее поля и менеджеров.

Proxy-модели создаются так же, как и обычная модель. 
Определяется в метаклассе дочерней модели через proxy = True.
Прокси-модели наследуют атрибуты Meta так же, как и обычные модели.
Прокси-модель должна наследоваться ровно от одного неабстрактного класса модели. 
Прокси-модель может наследоваться от любого количества прокси-моделей, которые имеют общий неабстрактный родительский класс.

Если вы не определите ни один менеджер для proxy-модели, он будет унаследован от родительской модели. 
Если вы определите менеджер, он будет использован как менеджер по умолчанию, в то же время будут доступны менеджеры, определенные в родительской модели.

# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True

class MyPerson(Person, ExtraManagers):
    class Meta:
        proxy = True


















