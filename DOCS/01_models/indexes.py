# ==========================================================================================================
# ИНДЕКСЫ
# ==========================================================================================================

# Класс создает индекс B-Tree в базе
class Index(*expressions, fields=(), name=None, db_tablespace=None, opclasses=(), condition=None, include=None):
    pass

expressions
# Аргумент разрешает создавать функциональные индексы по выражениям и функциям базы данных.
# Требует указания name  
# PostgreSQL требует, чтобы функции и операторы в индексе, были помечены как IMMUTABLE. Django не проверяет это, но PostgreSQL выдаст ошибку. Это означает, что такие функции, как Concat(), не принимаются.
# MySQL <8.0.13 и MariaDB не поддерживают функциональные индексы.

    Index(Lower('title').desc(), 'pub_date', name='lower_title_date_idx')
    # создает индекс для поля заголовка в нижнем регистре в порядке убывания и поля pub_date в порядке возрастания. 

    Index(F('height') * F('weight'), Round('weight'), name='calc_idx')
    # создает индекс для результата умножения полей высоты и веса и веса, округленного до ближайшего целого числа. 


fields = ['headline', '-pub_date']
# Список или кортеж имен полей, для которых требуется индекс.
# По умолчанию индексы создаются в порядке возрастания для каждого столбца. 
# Минус создаст индекс по убыванию для столбца.

name
# Имя индекса не длиннее 30 символов, не должно начинаться с цифр или _. Если не указано, Django автоматически сгенерирует. 
# При указании частичного индекса для абстрактного базового класса нужно исключить конфликт имен, так как параметр Meta.indexes наследуется подклассами с одинаковыми значениями атрибутов(включая имя). Для этого можно использовать такую конструкцию:
# name = '% (app_label) s _% (class) s_title_index'.

db_tablespace
# Имя табличного пространства БД для индекса. 
# Для индексов одного поля, если db_tablespace не предоставлено, индекс создается в Field.db_tablespace.
# Если Field.db_tablespace не указано (или индекс использует несколько полей), индекс создается в db_tablespace внутри класса модели Meta. 
# Если ни одно из этих табличных пространств не установлено, индекс создается в табличном пространстве таблицы.

opclasses
# Имена классов операторов PostgreSQL, используемых для индекса. Используется только в PostgreSQL.
# Если нужен собственный класс операторов, вы должны предоставить по одному для каждого поля в индексе.
# Например, GinIndex(name = 'json_index', fields = ['jsonfield'], opclasses = ['jsonb_path_ops']) 
# создает json_index в jsonfield с помощью jsonb_path_ops.
# Index.name требуется при использовании классов операций.

condition = Q(pages__gt = 400)
# Ограничение индекса.
# Пример индексирует только записи более 400 страниц.
# Требуется name
# Ограничения PostgreSQL: требует, чтобы функции в условии были IMMUTABLE. Django не проверяет это, но PostgreSQL выдаст ошибку.
# Сравнение дат из DateTimeField с объектами datetime может потребовать tzinfo, иначе сравнение может привести к изменяемой функции из-за преобразования, которое Django выполняет для поиска.
# Ограничения SQLite: накладывает ограничения на создание частичного индекса.
# Ограничения Oracle: не поддерживает частичные индексы. Их можно эмулировать с помощью функциональных индексов. Используйте миграцию, чтобы добавить индекс с помощью RunSQL.
# Ограничения MySQL и MariaDB: игнорируется

include
Index(name='covering_index', fields=['headline'], include=['pub_date'])
# include используются только PostgreSQL
# Позволит фильтровать headline и pub_date, но данные будут извлекаться только из индекса.
# Использование include приведет к получению меньшего индекса, чем использование индекса с несколькими столбцами.
# Неключевые столбцы не могут использоваться для сортировки или фильтрации.
# Требуется name