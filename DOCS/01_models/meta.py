from django.db import models

class Pizza(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    age = models.IntegerField()


    class Meta:
        
        verbose_name = "pizza"
        # Название модели в ед. числе. Если не указано, то из модель CamelCase станет camel case

        verbose_name_plural = "pizza"
        # Название модели в мн. числе. Если не указано, то создаст по правилу verbose_name + "s"
        
        abstract = True
        # Делает модель абстрактной.

        proxy = True
        # Модель унаследованная от другой модели будет создана как proxy-модель
        
        base_manager_name = "objects"
        # Имя атрибута менеджера, для использования в _base_manager модели
        
        default_manager_name = "objects"
        # Имя менеджера, используемого для _default_manager модели

        ordering = ['-pub_date', 'author'] 
        ordering = [F('author').asc(nulls_last=True)]
        # Сортировка по умолчанию при получении объектов:  ordering = ['-pub_date', 'author'] 
        # Используйте строку '?' чтобы сортировать случайно.
        # Второй пример сортирует по автору по возрастанию и значения = Null сделает последними
        # Сортировка не бесплатная операция. Каждое поле влияет на скорость выполнения запроса. 
        # Каждый внешний ключ добавит сортировку по умолчанию связанной модели.
        # Если для запроса не указан порядок, результаты возвращаются из БД в неопределенном порядке. 
        # Объекты с одинаковыми именами могут отображатся в разном порядке.

        permissions = [('can_deliver_pizzas', 'Can deliver pizzas')]
        # Дополнительные разрешения для ввода в таблицу разрешений при создании объекта.
        # Список 2-х элементных кортежей в формате (код разрешения, название разрешения).
        # Разрешения на добавление, изменение, удаление и просмотр автоматически создаются для каждой модели. 

        default_permissions = ['add', 'change']
        # Список разрешений по умолчанию = ['add', 'change', 'delete', 'view']. 
        # Можно сделать = [], если приложению не требуются разрешения по умолчанию. 
        # Он должен быть указан в модели до ее модели с помощью миграции, чтобы предотвратить создание любых пропущенных разрешений.


        indexes = [
            models.Index(fields=['last_name', 'first_name']),
            models.Index(fields=['first_name'], name='first_name_idx'),
            ]
        # Список индексов, которые нужно определить в модели:
        # 1 - создаст индекс по двум полям
        # 2 - создаст индекс по 1 полю и назовет индекс first_name_idx


        constraints = [models.CheckConstraint(check=models.Q(age__gte=18), name='age_gte_18')]
        # Список ограничений, которые нужно определить для модели

        app_label = 'myapp'
        # Если модель определена вне приложения из INSTALLED_APPS, она должна указать к какому приложению она относится
        # Если представить модель в формате app_label.object_name или app_label.model_name, можно использовать model._meta.label и model._meta.label_lower соответственно.

        db_table = 'music_album'
        # По умолчанию = appname_modelname. 
        # Настоятельно рекомендуем использовать нижний регистр, особенно при использовании MySQL.

        db_tablespace = 'mytable_space'
        # Имя tablespace БД для этой модели. 
        # По умолчанию = DEFAULT_TABLESPACE, если она определена. 
        # Если база данных не поддерживает tablespace для индексов, этот параметр будет проигнорирован.

        default_related_name = 'pizza_set'
        # Название для обратных связей к модели. 
        # По умолчанию <model_name>_set.  
        # Эта опция также устанавливает related_query_name.
        # Название поля обратной связи должно быть уникальным, будьте осторожны, если собираетесь наследоваться от модели. Чтобы избежать коллизий в названиях, можно добавить '%(app_label)s' и '%(model_name)s', которые будут заменены соответственно на название приложения модели и название модели в нижнем регистре.

        get_latest_by = ['-priority', 'order_date']
        # Имя поля или список имен полей модели для использования в методах latest() и early() Менеджера моделей.
        # Обычно DateField, DateTimeField или IntegerField.


        managed = True
        # Разрешает или запрезает джанго управлять таблицами(удалять, создавать). 
        # По умолчанию True. Все остальные этапы работы с моделью не изменяются.

        # False используется если таблица была создана другим способом(не стандартным). 
        # Для ясности лучше определить в модели все поля таблицы, которую отображает модель с managed=False.

        # Если модель с managed=False содержит ManyToManyField на другую неуправляемую модель, промежуточная таблица для хранения связи многое-ко-многим не будет создана.
        # Если модель с managed=False содержит ManyToManyField на управляемую модель, то модель будет создана. Можно переопределить такое поведение - создать модель для промежуточной таблицы (с необходимым managed) и указать использование этой модели через параметр ManyToManyField.through.

        # Правильное создание таблиц при тестировании в тестовой базе данных для модели с managed=False ложится на ваши плечи.

        # Если вы хотите переопределить поведение модели на уровне Python, вы можете использовать managed=False и создать копию существующей модели. Однако, есть лучшее решение для такой ситуации - Proxy-модели.


        order_with_respect_to
        # Объекты модели будут отсортированы относительно указанного поля. 
        # Почти всегда используется для ForeignKey. 
        # Можно использовать для сортировки связанных объектов по значению из родительского объекта.
        # После любого изменения нужно делать миграцию.

        # К объектам модели будет добавлено 2 доп. метода для получения и установки порядка связанных объектов: 
        # - get_RELATED_order() - название модели в нижнем регистре
        # - set_RELATED_order()

        # К связанным объектам будет добавлено 2 метода для получения объектов в определенном порядке:
        # - get_next_in_order()
        # - get_previous_in_order()

        # order_with_respect_to неявно использует ordering. 
        # Внутри он добавляет колонку в базе данных _order и указывает её в опции модели ordering. 
        # order_with_respect_to и ordering не могут использоваться вместе
        # сортировка из order_with_respect_to будет использоваться при любом получении объектов модели.

        required_db_features =  ['gis_enabled']
        # Список функций БД, которые нужны для работы модели. Учитываются при миграции.
        # Таблица для модели будет создана только если БД поддерживает GIS.
        # Эта опция полезна при тестировании на разных БД. 
        # Избегайте связей между моделями в разных БД. ORM не умеет обрабатывать такие ситуации.

        required_db_vendor = ['sqlite', 'postgresql']
        # Список поддерживаемых баз данных.
        # По умолчанию: sqlite, postgresql, mysql, oracle. 
        # Таблица для модели будет создана только если БД есть в списке.

        select_on_save = False
        # Обычно нет надобности менять эту настройку. 
        # По умолчанию False.
        # Указывает использовать ли старый(до 1.6) алгоритм работы django.db.models.Model.save().
        # Старый алгоритм использовал SELECT для определения существует ли запись для обновления.
        # Новый алгоритм сразу пробует обновить запись через UPDATE. 
        # В некоторых редких случаях UPDATE существующей записи не виден для Django. 
        # Например, в PostgreSQL срабатывание ON UPDATE возвращает NULL. 
        # В таких случаях новый алгоритм в конце концов попытается выполнить INSERT, даже если запись существует в базе данных.

        unique_together = ['driver', 'restaurant']
        # Вместо этого используйте UniqueConstraint с параметром ограничений.
        # Множество полей, комбинация значений которых должна быть уникальна.

        index_together
        # Вместо этого используйте параметр индексов.

        label = 'polls.Question'
        # Представление объекта, возвращает app_label.object_name.

        label_lower = 'polls.question'
        # Представление объекта, возвращает app_label.model_name.

