# ==========================================================================================================
# ПАРАМЕТРЫ ПОЛЯ
# ==========================================================================================================

# === null
Позволяет базе сохранить NULL в базе данных(указывается только для БД) 
Не рекомендуется в строковых полях - выдает 2 возможных значения: пустая строка "" и NULL. Правильно использовать только "" .  Исключние при ситуации unique=True and blank=True.
Для всех типов полей лучше указать blank=True.

# === blank
blank=True позволяет Джанге сохранять поле пустым(указывается для джанги)
Рекомендуется для строковых полей.

# === choices
Предназначен для статических данных, которые практически не меняются. 
Для динамических данных лучше использовать ForeignKey.
[(A, B), (A, B) ...]  
A - это значение в базе данных. 
B - название в форме для пользователей. 
Объявление вариантов внутри класса позволяет ссылаться на выбор, пример Media.MEDIA_CHOICES. 
Значения можно группировать в именнованные группы.
Каждый объект поля имеет специальный метод get_FOO_display(), который возвращает название поля.
Поля DateField и DateTimeField имеют методы get_next_by_FOO() и get_previous_by_FOO(), которые возвращают следующий и предыдущий объект.Эти Методы можно использовать только для уже сохраненных объектов.
blank=False без default создает в поле выбора "---------". Можно заменить на (None, 'Your String For Display').

MEDIA_CHOICES = [
    ('Audio', (
            ('vinyl', 'Vinyl'),
            ('cd', 'CD'),
        )
    ),
    ('Video', (
            ('vhs', 'VHS Tape'),
            ('dvd', 'DVD'),
        )
    ),
    ('unknown', 'Unknown'),
]

# IntegerChoices - класс для целочисленных значений
Place = models.IntegerChoices('Place', 'FIRST SECOND THIRD')
Place.choices
[(1, 'First'), (2, 'Second'), (3, 'Third')]

# TextChoices - класс дял строчных значений
MedalType = models.TextChoices('MedalType', 'GOLD SILVER BRONZE')
MedalType.choices
[('GOLD', 'Gold'), ('SILVER', 'Silver'), ('BRONZE', 'Bronze')]

# === db_column
Имя колонки в БД для хранения данных поля. 
По дефолту Django использует название поля.

# === db_index
При True создаст индекс в базе данных.

# === db_tablespace
Имя для индекса поля если db_index = True. 
По умолчнию можно задать в settings в переменной DEFAULT_INDEX_TABLESPACE, иначе db_tablespace модели.

# === default
Используется при создании модели, если значение не указано или None.

Значение поля по умолчанию: значение или вызываемый(callable) объект. 
Вызываемый объект будет вызван при создании нового объекта. 
Значение может быть неизменяемым объектом или вызываемой функцией с изменяемым объектом.

Для полей типа ForeignKey значением по умолчанию должно быть pk или to_field.

# === editable
При False, поле не будет отображаться в админке или любой другой ModelForm, пропускается при валидации модели. По умолчанию – True.

# === error_messages
Позволяет переопределить сообщения ошибок. 
Ключи ошибок такие: null, blank, invalid, invalid_choice, unique, unique_for_date и др. 
Эти ошибки часто не передаются в формы.

# === help_text
Описание поля - подсказка в интерфейсе администратора. Можно использовать HTML.

# === primary_key
primary_key=True - делает поле первичным ключом, по умолчанию id = models.AutoField(primary_key=True). 
Обязательно null=False и unique=True. 
PK доступен только для чтения. Если поменять значение в объекте, то будет создан новый объект.

# === unique
unique=True значение поля должно быть уникальным, автоматически создает индекс - db_index указывать не нужно. 
Если значение повторяется, то метод save() выдаст ошибку IntegrityError.

# === unique_for_date
Параметр должен быть равен названию DateField или DateTimeField поля, для которого значение должно быть уникальным. 
Например, если модель имеет поле title с unique_for_date="pub_date", тогда Django позволит сохранять записи только с уникальной комбинацией title и pub_date.

title = models.SlugField(max_length=250, unique_for_date='pub_date') 
pub_date = models.DateTimeField(default=timezone.now)

Для DateTimeField только дата значения будет учитываться. 
При USE_TZ=True, проверка будет выполнена в текущем часовом поясе.

Проверка выполняется методом Model.validate_unique() во время валидации модели, не на уровне базы данных. 
Если unique_for_date содержит поля, которые не входят в ModelForm (например, поле было указанно в exclude или содержит editable=False), Model.validate_unique() не будет выполнять эту валидацию.

# === unique_for_month
Аналогично unique_for_date, но значение будет уникально для месяца.

# === unique_for_year
Аналогично unique_for_date и unique_for_month.

# === verbose_name
Отображаемое имя поля. 
По дефолту Django создаст из имени атрибута поля, заменяя подчеркивание на пробелы.

# === validators
Список проверок(валидаторов) выполняемых для этого поля. https://djbook.ru/rel3.0/ref/validators.html
