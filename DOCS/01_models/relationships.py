from django.db import models


# ==========================================================================================================
# ForeignKey(MANY-TO-ONE)
# ==========================================================================================================
# Отношения "Много к одному": Много авто могут иметь только 1 производителя, а производитель много авто.
# Поле ForeignKey содержит ссылку на первичную модель произодителя Manufacturer. Имя поля = имя модели в нижнем регистре. 
# По умолчанию создается индекс в БД. Можно отключить db_index=False если не нужен join или используется кастомный индекс.
# Если такие отношения определены в абстрактном классе, то модель разрешается в наследнике абстрактного класса.

# вторичная модель
class Car(models.Model):

    # поле ForeignKey хранит идентификатор производителя
    # в БД это поле будет называться manufacturer_id. Название можно переопределить добавив db_column='xxx'.
    manufacturer = models.ForeignKey('Manufacturer', on_delete=models.CASCADE)

    # Если нужна связь на себя - принимает self часто.
    manufacturer = models.ForeignKey('self', on_delete=models.CASCADE)

    # Если нужна связь на модель которой еще нет - принимает название модели 'model_name'.
    manufacturer = models.ForeignKey('model_name', on_delete=models.CASCADE)

    # Если модель Manufacturer находится в другом app, указать ее можно в виде "name_app.Manufacturer".
    # Это разрешит проблему циклического импорта между приложениями.
    manufacturer = models.ForeignKey('name_app.Manufacturer', on_delete=models.CASCADE)

# первичная модель
class Manufacturer(models.Model):
    name = models.CharField(max_length=100)


# ===== Параметры on_delete=: =============================================================

# определяет что делать с привязанными объектами(авто), если производитель будет удален.

CASCADE
# Привязанные объекты будут удалены.
# При этом метод Model.delete() не вызывается, но сигналы pre_delete и post_delete будут отправлены каждому удаляемому объекту.

PROTECT
# Запрещает удаление категории, пока есть привязанные объекты - выдаст исключение django.db.models.ProtectedError.

SET_NULL
# устанавливает в поле у связанных объектов ForeignKey = NULL; возможно только если разрешено null=True.

SET_DEFAULT
# устанавливает связанным объектам ForeignKey = default; default должен быть указан.

SET()
# устанавливает связанным объектам значение или результат выполняемого объекта.

DO_NOTHING
# Ничего не делать. Если используемый тип БД следит за целостностью связей, будет вызвано исключение IntegrityError.


# ===== Другие параметры: ==================================================================

limit_choices_to={'name':'Audi'} 
# Ограничивает доступные значения выбором 1 модели.
# Может принять dict, Q или функцию(например для фильтрации по дате {'pub_date__lte': datetime.date.utcnow()}. 
# Если указана функция - она будет вызываеться при каждой валидации модели.

related_name='cars_related'
# Название для обратной связи от связанной модели. По умолчанию modelname + _set.
# Значение по умолчанию для related_query_name(название обратной связи при фильтрации результата запроса). Этот параметр обязателен для полей в абстрактной модели.
# related_name='+' запрещает обратную связь.

# В шаблоне обратная связь в модели Car без related_name:
{% for car in manufacturer.car_set.all %}
    {{ car.name }}
{% endfor %}

# В шаблоне обратная связь с related_name='cars_related':
{% for car in manufacturer.cars_related.all %}
    {{ car.name }}
{% endfor %}

related_query_name
# По умолчанию = related_name или default_related_name(если установлено), либо имя модели.

to_field
# Поле на которое ссылается, по умолчанию это pk. Если установить другое поле, то оно должно иметь unique=True.

db_constraint
# Создавать ли ограничение для внешнего ключа в базе данных, по умолчанию = True. 
# При False вы рискуете целостностью данных. False ставят если используется нецелостная база данных или шардинг. 
# При False, если связанный объект не существует, при обращении к нему будет вызвано исключение DoesNotExist.

swappable
# Нужно для миграций. По умолчанию True. 
# К примеру если ForeignKey ссылается на модель, указанную через настройку settings.AUTH_USER_MODEL, то связь в миграции будет использовать эту настройку, а не саму модель.


# ==========================================================================================================
# MANY-TO-MANY
# ==========================================================================================================
# Отношения "Многие ко многим". Подходит для отношений тегов и статей. 
# Будет использована связующая таблица, она создается сама, либо ее можно создать самим и назначить ее полю ManyToManyField.
# Промежуточную таблицу можно создать самим. В этом случае в ней можно хранить дополнительные данные.
# Для определения модели, которая ссылается сама на себя с помощью промежуточной модели, нужно использовать symmetrical=False


# ===== Первый способ создания отношений Многие ко многим ===============================================
# В любой из таблиц нужно определить поле ManyToManyField с ссылкой на другую таблицу.

class Person(models.Model):
    # В этой модели автоматически появится поле для получения групп
    name = models.CharField(max_length=128)
 
class Group(models.Model):
    name = models.CharField(max_length=128)
    # Желательно, чтобы название поля ManyToManyField было множественным называнием связанных объектов.
    # Таблица в которой будут определены такие отношения неважна - может быть любой.
    # Джанго автоматически создаcт связующую таблицу с именем appname_group(имя таблицы) + _persones(_имя поля ManyToManyField)
    persones = models.ManyToManyField(Person)


# ===== Второй способ создания отношений Многие ко многим ==============================================
# Этот вариант позволяет хранить в промежуточной таблице дополнительные данные.

# Целевая модель
class Person(models.Model):
    # В этой модели автоматически появится поле для получения групп
    name = models.CharField(max_length=128)
 
# Исходная модель
class Group(models.Model):
    name = models.CharField(max_length=128)
    # поле ManyToManyField указывает на связующую таблицу в параметре through
    # в какой именно из основных таблиц будет указано поле - неважно
    members = models.ManyToManyField(Person, through='Membership')

# Связующая таблица с дополнительными данными
class Membership(models.Model):
    # в связующей модели нужно явно указать внешние ключи на обе модели
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    
    # дополнительные данные
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)


# ===== ПАРАМЕТРЫ поля Many to Many =========================================================

related_name
# Обратная связь. Чтобы запретить related_name на '+'.

related_query_name
# По умолчанию = related_name или default_related_name(если установлено), либо имя модели.

limit_choices_to
# Не работает, если промежуточная модель сделана кастомно.

symmetrical
# Используется только при рекурсивной связи (self). 
# В таком случае классу не будет добавлен атрибут modelname_set, связь по дефолту принимает вид если я твой друг, то и ты мне друг. 
# Отменить симметрию можно так: symmetrical=False + обязательно указать related_name.
# Чтобы получить связанные объекты при symmetrical=True нужно - создать промеутоную таблицу.

through='Modelname'
# Поле для указание промежуточной модели.

Если связанные модели разные, создаются следующие поля:
    id: первичный ключ для связи.
    <containing_model>_id: id модели, которая содержит поле ManyToManyField.
    <other_model>_id: id модели, на которую ссылается ManyToManyField.

Если ManyToManyField ссылается на одну и ту же модель, будут созданы поля:
    id: первичный ключ для связи.
    from_<model>_id: id объекта основной модели (исходный объект).
    to_<model>_id: id объекта, на который указывает связь (целевой объект).

При рекурсивной связи, используя промежуточную модель вы должны использовать аргумент symmetrical=False

through_fields
# Используется в кастомных промежуточных моделях. 
# Указывает по каким полям связывать(это нужно если есть несколько полей на 1 модель)

db_table
# Имя для промежуточной таблицы(авто или кастомной).

db_constraint
# Создавать ли ограничение для внешнего ключа в БД, по умолчанию = True. 
# При False вы рискуете целостностью данных. False ставят если используется нецелостная база данных или шардинг. 
# При False, если связанный объект не существует, при обращении к нему будет вызвано исключение DoesNotExist. 
# Нельзя указать db_constraint и through одновременно.

swappable
# Нужно для миграций. По умолчанию True. 
# К примеру если ForeignKey ссылается на модель, указанную через settings.AUTH_USER_MODEL, то связь в миграции будет использовать эту настройку, а не саму модель.

validators
# ManyToManyField не поддерживает validators.

null
# null не влияет на работу поля т.к. нет способа сделать связь обязательной на уровне базы данных.


# ==========================================================================================================
# ONE-TO-ONE
# ==========================================================================================================
# Отношения "Один к одному". Часто применяется для расширения модели юзера. 
# Одна строка одной модели может быть связана только с одной строкой другой модели.
# Работает как ForeignKey с unique=True, но обратная связь возвращает один объект. 
# Может иметь рекурсивную и ленивую связь.

# Для обратной связи нужно обращаться по имени модели и ее полю: place.restaurant.serves_hot_dogs
# При попытке получить связанный объект, который не существует, будет вызвано исключение DoesNotExist.
# OneToOneField принимает все параметры ForeignKey + 1 дополнительный:

primary_key = True
# внешний ключ через который идет связь с главной моделью будет также pk. Соответственно поле pk для этой модели не будет создано


# базовая модель
class Person(models.Model):
    # неявно создается еще одно свойство с именем зависимой модели - author,
    # оно указывает на связанный с этим объектом объект автора
    name = models.CharField(max_length=100)


# расширяющая модель
class Author(models.Model):
    # первый параметр определяет с какой моделью ассоциировать сущность
    # on_delete = models.CASCADE - объект этой модели будет удален, если будет удален связанный объект Person
    # primary_key = True - внешний ключ через который идет связь с главной моделью будет также pk. Соответственно поле pk для этой модели не будет создано.
    person = models.OneToOneField('Person', on_delete = models.CASCADE, parent_link=True)
    salary = models.PositiveIntegerField()

























