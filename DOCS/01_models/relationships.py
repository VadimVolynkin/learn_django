from django.db import models


# ==========================================================================================================
# ForeignKey(MANY-TO-ONE)
# ==========================================================================================================
# Отношения "Много к одному": Много авто могут иметь только 1 производителя, а производитель много авто.
# Модель Car содержит поле с ссылкой на модель произодителя Manufacturer. Имя поля = имя модели в нижнем регистре. 
# По умолчанию создается индекс в БД. Можно отключить db_index=False если не нужен join или используется кастомный индекс.
# Поле manufacturer в таблице БД модели Car будет называться manufacturer_id. Назване можно переопределить в db_column.
# Если такие отношения определены в абстрактном классе, то модель разрешается в наследнике абстрактного класса.

class Car(models.Model):
    manufacturer = models.ForeignKey('Manufacturer', on_delete=models.CASCADE)

    # Если нужна связь на себя - принимает self часто (используется в комментариях).
    manufacturer = models.ForeignKey('self', on_delete=models.CASCADE)

    # Если нужна связь на модель которой еще нет - принимает название модели 'model_name'.
    manufacturer = models.ForeignKey('model_name', on_delete=models.CASCADE)

    # Если модель Manufacturer находится в другом app, указать ее можно в виде "name_app.Manufacturer".
    # Это разрешит проблему циклического импорта между приложениями.
    manufacturer = models.ForeignKey('name_app.Manufacturer', on_delete=models.CASCADE)


class Manufacturer(models.Model):
    pass


# ===== Параметры on_delete=:
# параметр определяет что будет происходить с привязанными объектами, если объект будет удален.

CASCADE
# Привязанные объекты будут удалены.
# При этом метод Model.delete() не вызывается, но сигналы pre_delete и post_delete будут отправлены каждому удаляемому объекту.

PROTECT
# Привязанные объекты не будут удалены, выдаст исключение django.db.models.ProtectedError.

SET_NULL
# устанавливает связанным объектам ForeignKey = NULL; возможно только если null равен True.

SET_DEFAULT
# устанавливает связанным объектам ForeignKey = default; default должен быть указан.

SET()
# устанавливает связанным объектам значение или результат выполняемого объекта.

DO_NOTHING
# Ничего не делать. Если используемый тип БД следит за целостностью связей, будет вызвано исключение IntegrityError.

# ===== Другие параметры:

limit_choices_to={'name':'Audi'} 
# Ограничивает доступные значения выбором 1 модели.
# Может принять dict, Q или функцию(например для фильтрации по дате {'pub_date__lte': datetime.date.utcnow()}. 
# Если указана функция - она будет вызываеться при каждой валидации модели.

related_name='cars_related'
# Название для обратной связи от связанной модели. По умолчанию modelname + _set.
# Значение по умолчанию для related_query_name(название обратной связи при фильтрации результата запроса). Этот параметр обязателен для полей в абстрактной модели.
# related_name='+' запрещает обратную связь.

# В шаблоне обратная связь в модели Car без related_name:
{% for car in manufacturer.car_set.all %}
    {{ car.name }}
{% endfor %}

# В шаблоне обратная связь с related_name='cars_related':
{% for car in manufacturer.cars_related.all %}
    {{ car.name }}
{% endfor %}

related_query_name
# По умолчанию = related_name или default_related_name(если установлено), либо имя модели.

to_field
# Поле на которое ссылается, по умолчанию это pk. Если установить другое поле, то оно должно иметь unique=True.

db_constraint
# Создавать ли ограничение для внешнего ключа в базе данных, по умолчанию = True. 
# При False вы рискуете целостностью данных. False ставят если используется нецелостная база данных или шардинг. 
# При False, если связанный объект не существует, при обращении к нему будет вызвано исключение DoesNotExist.

swappable
# Нужно для миграций. По умолчанию True. 
# К примеру если ForeignKey ссылается на модель, указанную через настройку settings.AUTH_USER_MODEL, то связь в миграции будет использовать эту настройку, а не саму модель.


# ==========================================================================================================
# MANY-TO-MANY
# ==========================================================================================================

Желательно, чтобы название поля ManyToManyField было множественным называнием связанных объектов.

related_name
# Обратная связь. Чтобы запретить related_name на '+'.

related_query_name
# По умолчанию = related_name или default_related_name(если установлено), либо имя модели.

limit_choices_to
# Не работает, если промежуточная модель сделана кастомно.

symmetrical
# Используется только при рекурсивной связи (self). 
# В таком случае классу не будет добавлен атрибут modelname_set, связь по дефолту принимает вид если я твой друг, то и ты мне друг. 
# Отменить симметрию можно так: symmetrical=False + обязательно указать related_name.
# Чтобы получить связанные объекты при symmetrical=True нужно - создать промеутоную таблицу.

through
# Джанго сам создает промежуточную модель. 
# Если нужно хранить еще какие то данные, то можно создать свою промежуточную модель с ForeignKey ключами и назначить ее в through='Model'.

Если связанные модели разные, создаются следующие поля:
    id: первичный ключ для связи.
    <containing_model>_id: id модели, которая содержит поле ManyToManyField.
    <other_model>_id: id модели, на которую ссылается ManyToManyField.

Если ManyToManyField ссылается на одну и ту же модель, будут созданы поля:
    id: первичный ключ для связи.
    from_<model>_id: id объекта основной модели (исходный объект).
    to_<model>_id: id объекта, на который указывает связь (целевой объект).

При рекурсивной связи, используя промежуточную модель вы должны использовать аргумент symmetrical=False

through_fields
# Используется в кастомных промежуточных моделях. 
# Указывает по каким полям связывать(это нужно если есть несколько полей на 1 модель)

from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=50)

class Group(models.Model):
    name = models.CharField(max_length=128)
    # group – ключ, который ссылается на модель с ManyToManyField
    # person – ключ, который ссылается на целевую модель
    members = models.ManyToManyField(Person, through='Membership', through_fields=('group', 'person'),)

class Membership(models.Model):
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    inviter = models.ForeignKey(Person, on_delete=models.CASCADE, related_name="membership_invites",)
    invite_reason = models.CharField(max_length=64)


db_table
# Имя для промежуточной таблицы(авто или кастомной).

db_constraint
# Создавать ли ограничение для внешнего ключа в БД, по умолчанию = True. 
# При False вы рискуете целостностью данных. False ставят если используется нецелостная база данных или шардинг. 
# При False, если связанный объект не существует, при обращении к нему будет вызвано исключение DoesNotExist. 
# Нельзя указать db_constraint и through одновременно.

swappable
# Нужно для миграций. По умолчанию True. 
# К примеру если ForeignKey ссылается на модель, указанную через settings.AUTH_USER_MODEL, то связь в миграции будет использовать эту настройку, а не саму модель.

validators
# ManyToManyField не поддерживает validators.

null
# null не влияет на работу поля т.к. нет способа сделать связь обязательной на уровне базы данных.


# ==========================================================================================================
# ONE-TO-ONE
# ==========================================================================================================
# Отношения "Один к одному". Применяется для расширения модели. 
# Работает как ForeignKey с unique=True, но обратная связь возвращает один объект. Может иметь рекурсивную и ленивую связь.

# Для обратной связи не нужно использовать FOO_set, нужно обращаться сразу по имени модели и ее полю: place.restaurant.serves_hot_dogs
# При попытке получить связанный объект через обратную связь, если объект не существует, будет вызвано исключение DoesNotExist.

# Парметры OneToOneField. Принимает все параметры ForeignKey + 1 дополнительный:

parent_link
# При True и связанной модели, которая наследуется от другой модели, определяет, что должна сохраняться связь на родительскую модель, а не поле OneToOneField дочерней модели, которое используется для организации наследования моделей.


# ==========================================================================================================
# АТРИБУТЫ МОДЕЛИ
# ==========================================================================================================
objects - менеджер по умолчанию.
Каждый неабстрактный класс Model должен иметь экземпляр класса Manager. Это интерфейс, через который Django выполняет запросы к базе данных и получает объекты. Менеджеры доступны только через класс модели, они не доступны в экземплярах модели.

# Менеджер можно переопределить: в классе указать:
new_manager  = models.Manager()


# ==========================================================================================================
# МЕТОДЫ МОДЕЛИ
# ==========================================================================================================
Методы модели работают с конкретной записью в таблице.

__str__()
# метод Python, возвращающий строковое представление любого объекта

get_absolute_url()
# Указывает Django, какой URL строить для объекта. 
# Каждый объект, который имеет уникальный URL должен иметь этот метод.
# Обычно используется для создания урла картинок.

save()

delete()

# Встроенные методы можно переопределять.
# Переопределенные методы модели не вызываются при множественных операциях(bulk при массовом удалении объектов через QuerySet, или как результат каскадного удаления). 
# Для гарантированного выполнения действий после удаления объекта используйте сигналы pre_delete и/или post_delete.
# К сожалению, вы не сможете изменить логику сохранения объектов при использовании creating или updating, так как save(), pre_save и post_save не будут выполнены.


























